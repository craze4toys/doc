= Complément sur les gestionnaires de signaux

Jetons un autre coup d'oeil à GLib::Instantiatable#signal_connect:

  % irb --simple-prompt
  >> require 'gtk2'
  => true
  >> b = Gtk::Button.new("hoge")
  => #<Gtk::Button:0x40a2a858 ptr=0x8237df8>
  >> b.signal_connect("clicked") { puts 1 }
  => 1
  >> b.signal_connect("clicked") { puts 2 }
  => 2
  >>

Avez-vous remarqué le nombre entier retourné?

Il s'agit d'une marque identifiant votre bloc de code de rappel.  Comme vous pouvez le constater
plus haut, vous pouvez installer autant de gestionnaires de signaux que vous voulez sur un objet, 
et ils seront tous exécutés dans l'ordre de leur installation.

Nous allons maintenant émettre un signal manuellement.  La méthode 
GLib::Instantiatable#emit_signal va envoyer un signal spécifié par un nom de signal passé en argument.

Nous pouvons observer ici que nos blocs de code sont appelés dans l'ordre de leur installation:

  >> b.signal_emit("clicked")
  1 
  2
  => nil
  >>

GLib::Instantiatable#signal_handler_disconnect est utilisé pour retirer un gestionnaire de signal préalablement installé, en se basant sur une marque retournée par GLib::Instantiatable#signal_connect:

  >> b.signal_handler_disconnect 1
  => #<Gtk::Button:0x40a2a858 ptr=0x8237df8>
  >> b.signal_emit("clicked")
  2
  => nil
  >>

Vous pouvez temporairement désactiver un bloc de code de rappel avec 
GLib::Instantiatable#signal_handler_block et GLib::Instantiatable#signal_handler_unblock:

  >> b.signal_handler_block 2
  => #<Gtk::Button:0x40a2a858 ptr=0x8237df8>
  >> b.signal_emit("clicked")
  => nil
  >> b.signal_handler_unblock 2
  => #<Gtk::Button:0x40a2a858 ptr=0x8237df8>
  >> b.signal_emit("clicked")
  2
  => nil
  >>
