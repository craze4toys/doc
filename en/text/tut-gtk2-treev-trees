= The Tree View Widget
{{link "tut-gtk2-treev-parts", "tut-gtk2-treev", "tut-gtk", "tut-gtk2-treev-rr"}}

== Using Gtk::TreeStore

There is one more type of built-in tree model called Gtk::TreeStore which provides the same functionality as Gtk::ListStore, except the data can be organized into a multilayered tree. Just like Gtk::ListStore, the Gtk::TreeStore object is a tree model for use with a Gtk::TreeView widget. It implements the Gtk::TreeModel interface, and inherits all of its methods. It also implements the Gtk::TreeSortable interface so you can sort the list using the view. Finally, it also implements the tree drag and drop interfaces.

{{image_right("treev-trees-ok.png")}}

Our example program "treestore.rb" is a revised version of the "Grocery List" program from the previous session, splitting the products into two categories: "Cleaning Supplies" and "Food", which both have children of their own. The quantity of each category is set initially to zero, and is calculated during the run-time, just momentarily before it is displayed as 4 and 7 respectively.  Note, there are two logical columns under the header ((*Buy.*)) The left logical column represents the parent column with a small expander triangle at the edge, slightly shifted to the right is the row of children.

{{br}}

((*treestore.rb*))

 #!/usr/bin/env ruby
 require 'gtk2'
 
 # Add three columns to the GtkTreeView. All three of the
 # columns will be displayed as text, although one is a boolean
 # value and another is an integer.
 def setup_tree_view(treeview)
   # Create a new GtkCellRendererText, add it to the tree
   # view column and append the column to the tree view.
   renderer = Gtk::CellRendererText.new
   column = Gtk::TreeViewColumn.new("Buy", renderer, "text" => $buy_it)
   treeview.append_column(column)
   renderer = Gtk::CellRendererText.new
   column = Gtk::TreeViewColumn.new("Count", renderer, "text" => $quantity)
   treeview.append_column(column) 
   renderer = Gtk::CellRendererText.new
   column = Gtk::TreeViewColumn.new("Product", renderer, "text" => $product)
   treeview.append_column(column)
 end
 
 window = Gtk::Window.new(Gtk::Window::TOPLEVEL)
 window.resizable = true
 window.title = "Grocery List"
 window.border_width = 10
 window.signal_connect('delete_event') { Gtk.main_quit }
 window.set_size_request(275, 300)
 
 class GroceryItem
   attr_accessor :product_type, :buy, :quantity, :product
   def initialize(t,b,q,p)
     @product_type, @buy, @quantity, @product = t, b, q, p
   end
 end
 $buy_it = 0; $quantity = 1; $product = 2
 $p_category = 0; $p_child = 1
 
 list = Array.new
 list[0] = GroceryItem.new($p_category, true,  0, "Cleaning Supplies")
 list[1] = GroceryItem.new($p_child,    true,  1, "Paper Towels")
 list[2] = GroceryItem.new($p_child,    true,  3, "Toilet Paper")
 list[3] = GroceryItem.new($p_category, true,  0, "Food")
 list[4] = GroceryItem.new($p_child,    true,  2, "Bread")
 list[5] = GroceryItem.new($p_child,    false, 1, "Butter")
 list[6] = GroceryItem.new($p_child,    true,  1, "Milk")
 list[7] = GroceryItem.new($p_child,    false, 3, "Chips")
 list[8] = GroceryItem.new($p_child,    true,  4, "Soda")
 
 treeview = Gtk::TreeView.new
 setup_tree_view(treeview)
 
 # Create a new tree model with three columns, as Boolean, 
 # integer and string.
 store = Gtk::TreeStore.new(TrueClass, Integer, String)
 
 # Avoid creation of iterators on every iterration, since they
 # need to provide state information for all iterations. Hence:
 # establish closure variables for iterators parent and child.
 parent = child = nil

 # Add all of the products to the GtkListStore.
 list.each_with_index do |e, i|

   # If the product type is a category, count the quantity
   # of all of the products in the category that are going
   # to be boughty.
   if (e.product_type == $p_category)
     j = i + 1

     # Calculate how many products will be bought in
     # the category.
     while j < list.size && list[j].product_type != $p_category
       list[i].quantity += list[j].quantity if list[j].buy
       j += 1
     end
    
     # Add the category as a new root (parent) row (element).
     parent = store.append(nil)
     # store.set_value(parent, $buy_it, list[i].buy # <= same as below
     parent[$buy_it]   = list[i].buy
     parent[$quantity] = list[i].quantity
     parent[$product]  = list[i].product

   # Otherwise, add the product as a child row of the category.
   else
     child = store.append(parent)
     # store.set_value(child, $buy_it, list[i].buy # <= same as below
     child[$buy_it]   = list[i].buy
     child[$quantity] = list[i].quantity
     child[$product]  = list[i].product
   end
 end
 
 # Add the tree model to the tree view
 treeview.model = store
 scrolled_win = Gtk::ScrolledWindow.new
 scrolled_win.add(treeview)
 scrolled_win.set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC)
 window.add(scrolled_win)
 window.show_all
 Gtk.main

The only difference between a Gtk::TreeView with a Gtk::TreeStore instead of a Gtk::ListStore is in the creation of the ((*store*)) - a tree model with three columns defined as Boolean, integer and a string.

Adding columns and renderers renderers is performed in the same manner with both models, because columns are part of the view not the model:
:Reminder: What is MVC
    ((*model-view-controller*)) (MVC) design is a design method where the information and the way it is rendered are separated, which is similar to the relationship between Gtk::TreeView and Gtk::TreeBuffer. 


((*Tree stores*)) are initialized with Gtk::ListStore.new.

 # Create a new tree model with three columns, as Boolean,
 # integer and string.
 store = Gtk::ListStore.new(TrueClass, Integer, String)

However the most important difference is in how iterators and parent and child columns are handled. The first change that became an important feature in the ((*store*)) data initialization process was a new attribute called "product_type" in the GroceryItem class. This attribute decides whether a data item (a row, a record, or a tuple) is a product_category designated as the parent column in our data structure, or a grocery product which in our data structure is a child column of the product_category.

Hence, when we are creating rows we have to create a column of parents and a column of children. The two are created in a slightly different way. The first difference is in the argument to the row creation method Gtk::TreeStore#append(parent). Namely, if the argument here called parent is nil we are creating parent row, when it is a non-nil Gtk::TreeIter we are creating a child of the parent to which the  Gtk::TreeIter attribute points. Gtk::TreeStore#append method returns an iterator which points to the newly created empty data item (row, record, or tuple). This iterator is then used to assign values to the columns in the empty row. We add three columns, hence three lines with the method: Gtk::TreeStore#set_value(iter, column, value). Let's look at the code fragment that illustrates the above narrative:

 # Add all of the products to the GtkListStore.
 list.each_with_index do |e, i|

   if (e.product_type == $p_category)
        . . .
     # Add the category as a new root element.
     iter = store.append(nil)
     store.set_value(iter, $buy_it,   list[i].buy)
     store.set_value(iter, $quantity, list[i].quantity)
     store.set_value(iter, $product,  list[i].product)
 
   # Otherwise, add the product as a child of the category.
   else
     child = store.append(iter)
     store.set_value(child, $buy_it,   list[i].buy)
     store.set_value(child, $quantity, list[i].quantity)
     store.set_value(child, $product,  list[i].product)
   end
 end
