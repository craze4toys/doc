= The Text View Widget
{{link "tut-gtk2-txtw-textview", "tut-gtk2-txtw", "tut-gtk", "tut-gtk2-txtw-tags"}}

== Text Iterators and Marks

When manipulating text within a Gtk::TextBuffer object, there are two different objects that can help you track the position within the buffer: Gtk::TextIter and Gtk::TextMark. Functions are provided by GTK+ to translate between these two objects.

:Text Iterators

    If I borrow the terminology from geometry, we can say that text iterators are used define the an interval of text in a text buffer. They are a transient or ephemeral in nature, because they are meant to be used immediately after their initialization and became invalid as soon as the text buffer is edited. Iterators are better than offset or byte index into a buffer, because they are guarantied to point at the beginning of an UTF-8 character, which may be a string of multiple bytes.

:Text Marks

    For keeping track of the position in a text buffer throughout the editing process Gtk::TextMark object is provided. Text marks remain intact even when text buffer is changed, and will move the position based on how the the text buffer is manipulated. You can retrieve an iterator position at a text mark with Gtk::TextBuffer#get_iter_at_mark(mark):

     get_iter_at_mark(mark)
         Gets the iter with the current position at mark.
         * mark: a Gtk::TextMark in buffer 
         * Returns: a Gtk::TextIter
    {{br}}

=== Text Marks

Text marks act as if they were invisible cursors within the text, changing position depending on how the text is edited. For instance, if the text is added before the mark, it will move to the right so that it remains at the same textual position.

By default, text marks have ((*gravity*)) set to the right, hence a text mark will move to the right as new text is added. If text is removed the mark will move between the two pieces of text on either side of the removed text. Then if the text is inserted at that position, because of its right gravity setting, the mark will remain on the right side of the inserted text. You can see that the text mark behaves just like a cursor in most text editors.

:Text mark Visibility:
    By default, text marks are invisible within the text, however, you can make them visible by setting Gtk::TextBuffer#visible=(boolean) to true.


Text marks can be accessed in two ways. You can retrieve a text mark at a specific Gtk::TextIter location. It is also possible to set up text mark with a string as its name, which makes it easy to keep track of.

Two default text marks are always available by GTK+ for every Gtk::TextBuffer: ((*insert*)) and ((*selection_bound.*)) The insert text mark refers to the current cursor position within the buffer. The selection_bound text mark refers to the boundary of selected (highlighted) text if there is any selected text. If there isn't any text selected these two marks will point to the same position.

The  ((*insert*)) and ((*selection_bound*)) text marks are extremely useful. They can be set to automatically select or deselect text within a buffer and help you figure out where text should be inserted within the buffer.

== Editing the Text Buffer

{{image_right("txtw-itrsmrks-01.png")}}

GTK+ provides a wide variety of methods for retrieving text iterators as well as manipulating text buffers. Not to overwhelm ourselves we will first  start exploring a few, and later some more. The next program example  is an application capable of retrieving and inserting text into a text buffer:


{{br}}

 #!/usr/bin/env ruby
 require 'gtk2'

 # Insert the text from the GtkEntry into the GtkTextView.
 def insert_text(ent, txtvu)
   mark = txtvu.buffer.selection_bound
   iter = txtvu.buffer.get_iter_at_mark(mark)
   txtvu.buffer.insert(iter, ent.text)
 end

 # Retrieve the selected text from the GtkTextView and
 # display it to the user.
 def retrieve_text(tw)
   start_iter, end_iter = tw.buffer.bounds

   # Problems as of:  Ruby 1.8.6 and Ruby-GNOME2
   # rel.: 2-0.17.0-rc1.
   #
   # Does not allow start, end iterator arguments
   # text = tw.buffer.text ##### (startm, endm)
   # ------------------------------------------
   # However, the following works on the surface
   # but doesn't do what is expected.

   text = tw.buffer.get_text(start_iter, end_iter)
   puts "#{text}"
 end

 window = Gtk::Window.new(Gtk::Window::TOPLEVEL)
 window.resizable = true
 window.title = "Text Iterators"
 window.border_width = 10
 window.signal_connect('delete_event') { Gtk.main_quit }
 window.set_size_request(250, 150)

 textview = Gtk::TextView.new

 entry    = Gtk::Entry.new
 insert   = Gtk::Button.new("Insert Text")
 retrieve = Gtk::Button.new("Get Text")

 insert.signal_connect('clicked') { insert_text(entry, textview) }
 retrieve.signal_connect('clicked') { retrieve_text(textview) }

 scrolled_win = Gtk::ScrolledWindow.new
 scrolled_win.border_width = 5
 scrolled_win.add(textview)
 scrolled_win.set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_ALWAYS)

 hbox = Gtk::HBox.new(false, 5)
 hbox.pack_start_defaults(entry)
 hbox.pack_start_defaults(insert)
 hbox.pack_start_defaults(retrieve)
 vbox = Gtk::VBox.new(false, 5)
 vbox.pack_start(scrolled_win, true,  true, 0)
 vbox.pack_start(hbox,         false, true, 0)
 window.add(vbox)
 window.show_all
 Gtk.main

It is not to be expected that serious readers of this tutorial would have any difficulty understanding the main body of this example program. You may have guessed that the most important processing is happening in two top level methods (defined for Object object) ((*insert_text*)) and  ((*retrieve_text.*))

In insert_text(entry, textview) we first have to retrieve the text mark, which is next translated into text iterator, and then in turn used to insert a string from Gtk::Entry text field into the text buffer.

In retrieve_text(textview) we first obtain two text iterators representing start/end positions of the selected (highlighted) text, which are subsequently used to obtain the marked (selected) text from the text buffer.


=== Retrieving Text Iterators and Marks

In the above example program we first obtain the text mark with Gtk::TextBuffer#selection_bound. Note that the following two lines have identical effect and meaning:

     mark = textview.buffer.selection_bound
     mark = textview.buffer.get_mark("selection_bound")

These methods return Gtk::TextMark object. Once we have the have a text mark, we have to translate it into text iterator with Gtk::TextBuffer#get_iter_at_mark(mark). This method returns a  Gtk::TextIter object.

 iter = textview.buffer.get_iter_at_mark(mark)

The other method for retrieving text iterators in our function called "retrieve_text" is Gtk::TextBuffer#bounds. It returns an array with the starting and ending Gtk::TextIter objects, which identify the selected text interval in the text buffer.

When you have the two iterators you have to supply them to Gtk::TextBuffer#get_text(start, end, show_invisible=false), to retrieve the selection.

{{image_right("dialog-warning.png")}}

Unfortunately Gtk::TextBuffer#get_text currently does not work as expected. Those of you who wish see the identical C GTK+ program, that does work, can click on this  link ((<"C GTK+ program: Using Text Iterators"|tut-gtk2-txtw-itrsmrks-cgtk-01>)) (you will be making a short detour into C GTK+).

:Caution:
    When the above Gtk::TextBuffer#get_text will work, you should be careful that there are no images or other non-textual object in the text buffer, since the character positions will because of this most likely be off. In such cases you should use Gtk::TextBuffer#get_slice instead.

    Also, recall that positions refer to character and not byte positions.

GTK+ also provides Gtk::TextBuffer#get_iter_at_line_index(line_number, byte_index), which will choose a position of an individual byte on the specified line. You should be extremely careful when using this function, because the index must always point to the beginning of a UTF-8 character, which may be more than one byte wide.

Rather than choosing a character offset (at an index), you may retrieve the first iterator on a specified line with Gtk::TextBuffer#get_iter_at_line(line_number).


You can also get an iterator at an offset from the beginning of a line Gtk::TextBuffer#get_iter_at_line_offset(line_number, char_offset).

=== Changing Text Buffer Contents


So far we have been dealing with the contents of an entire text buffer. In fact the first thing you learnt was how to reset the buffer to a new value with

 Gtk::TextBuffer#.text = "Some text" 

Subsequently we've learnt how to manipulate the entire buffer. However, it is also useful to edit just a portion of a document. There are quite a number of such methods available to you:

* Gtk::TextBuffer#insert(iter, text)
* Gtk::TextBuffer#insert(iter, text, tag1, tag2, tag3, ...)
* Gtk::TextBuffer#insert(iter, pixbuf)
* Gtk::TextBuffer#insert(iter, anchor)
* Gtk::TextBuffer#insert_at_cursor(text)
* Gtk::TextBuffer#insert_interactive(iter, text, default_editable)
* Gtk::TextBuffer#insert_interactive_at_cursor(text, default_editable)
* Gtk::TextBuffer#insert_range(iter, start, end)
* Gtk::TextBuffer#insert_range_interactive(iter, start, end, default_editable)
