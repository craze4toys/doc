= Menus and Toolbars
{{link "tut-gtk2-mnub", "tut-gtk2-mnstbs", "tut-gtk", "tut-gtk2-mnstbs-tbi"}}

== Toolbars

A Gtk::Toolbar is a type of container that holds a number of widgets in a horizontal or vertical row. It is meamt to allow easier customization of large number of widgets with very little trouble. Typically toolbars hold tool buttons that can display an image along with a text string. However, toolbars are actually able to hold any type of widget.


{{image_right("mnstbs-tb-01.png")}}

In the example program here, a simple toolbar is created that that shows five tool items in a horizontal row. Each toolbar item displays an icon and a label that describes the purpose of the item. The toolbar is also set to display an arrow that will that will provide access to toolbar items that do not fit in the menu.

In this example, a toolbar is used to provide cut, copy paste, and select-all functionality to the Gtk::Entry widget. The main program line (body) creates the toolbar, packing it above the entry widget. It then calls "create_toolbar", which populates the toolbar with tool items and connects the needed signals.

{{image_left("mnstbs-tb-02.png")}}
{{image_right("dialog-warning.png")}}
Again, there is a minor problem here, namely the vertical ((*separator*)) is not yet supported in the current Ryby/GNOME2 (2-0.17.0-rc1) release. Nor does the instance method ((*show_arrow=true*)) yield a desired behaviour!? These are only problems in Ruby implementation, and work in C GTK+ implementation. You can see the both the separator and the arrow features on the image above, as displayed by the toolbars.c - C GTK+ version of our example program.

{{br}}
((*toolbars.rb*))

 #!/usr/bin/env ruby
 require 'gtk2'
 
 # Create a toolbar with Cut, Copy, Paste and Select All
 # toolbar items.
 def create_toolbar(tb, ent)
   cut = Gtk::Button.new(Gtk::Stock::CUT)
   copy = Gtk::Button.new(Gtk::Stock::COPY)
   paste = Gtk::Button.new(Gtk::Stock::PASTE)
   selectall = Gtk::Button.new(Gtk::Stock::SELECT_ALL)
 #  separator = Gtk::SeparatorToolItem.new
 
   tb.show_arrow=(true)
   tb.toolbar_style=(Gtk::Toolbar::Style::BOTH)
 
   # NOTE: tool-tips are only part of the deprecated interface ?!
   tb.insert(0, cut, "Cut out the text")
   tb.insert(1, copy)
   tb.insert(2, paste)
 #  tb.insert(3, separator)
   tb.insert(4, selectall)
 
   cut.signal_connect('clicked')       { ent.cut_clipboard }
   copy.signal_connect('clicked')      { ent.copy_clipboard }
   paste.signal_connect('clicked')     { ent.paste_clipboard }
   selectall.signal_connect('clicked') { select_all(ent) }
 end
 
 # Select all of the text in the GtkEditable.
 def select_all(edit)
 # gtk_editable_select_region (entry, 0, -1);
   edit.select_region(0, -1)
 end
 
 window = Gtk::Window.new(Gtk::Window::TOPLEVEL)
 window.resizable = true
 window.title = "Toolbars"
 window.border_width = 10
 window.signal_connect('delete_event') { Gtk.main_quit }
 window.set_size_request(325, -1)
 
 entry   = Gtk::Entry.new
 toolbar = Gtk::Toolbar.new
 create_toolbar(toolbar, entry)
   
 vbox = Gtk::VBox.new(false, 5)
 vbox.pack_start_defaults(toolbar)
 vbox.pack_start_defaults(entry)
 
 window.add(vbox)
 window.show_all
 Gtk.main


New toolbars are created with Gtk::Toolbar.new. This creates an empty toolbar. We created our toolbar before calling our own method create_toolbar(toolbar, entry), which populates the toolbar.

Gtk::Toolbar class provides a number of properties for customizing how it appears and interacts with the user including the orientation, button style, and the ability to give access to items that do not fit in the toolbar. The one property managing instance method worth mentioning here is the Gtk::Toolbar#toolbar_style, because it requires you to be aware of the appropriate constants (((<GtkToolbarStyle|Gtk::Toolbar#GtkToolbarStyle>))). Also note the Gtk::Toolbar#show_arrow method

   tb.show_arrow = true
   tb.toolbar_style=(Gtk::Toolbar::Style::BOTH)
