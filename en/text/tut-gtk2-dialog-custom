= Dialogue Widgets
{{link "tut-gtk2-dialog", "tut-gtk2-dialog", "tut-gtk", "tut-gtk2-dialog-msg"}}


== Creating Your Own Dialogs

A dialog is a special type of Gtk::Window that is used to supplement the top-level window. Dialog widgets are split in half by horizontal separator. The top half is where you place the main part of the dialog's user interface. The bottom half, called the "action area" holds a collection of buttons. When clicked, each button will emit a unique response identifier that tells the programmer which button was pressed.

=== Gtk::Dialog

Dialog boxes are a convenient way to prompt the user for some input, like to display a message, ask a question, etc. Ruby/GTK treats a dialog as a window split vertically. The top section is a ((*vertical box*)), and is where widgets such as a Gtk::Label or a Gtk::Entry should be packed. The bottom area is known as the ((*action_area*)), and is generally used for packing buttons into the dialog which may perform actions such as cancel, ok, or apply. The two areas are separated by an optional Gtk::HSeparator. 

Gtk::Dialog boxes are created with a call to Gtk::Dialog.new. To access the two primary areas of the dialogue you can use Gtk::Dialog#vbox and Gtk::Dialog#action_area. The action area holds all the buttons along the bottom of the dialog. Though you could manually add buttons to the Gtk::Dialog#action_area by calling Gtk::HButtonBox#add_child and Gtk::ButtonBox#Style (see: ((<Button Box|tut-gtk2-btt-bttbox>))), it is recommended that you use the methods provided by Gtk::Dialog. You can think of the Gtk::Dialog as a vertical box, where both the ((*action_area*)) and the ((*separator*)) are packed at the end, so you should use "Gtk::Dialog#vbox .pack_start" or "Gtk::Dialog#vbox .pack_start_default" to add widgets to a Gtk::Dialog. However, currently (as of Ruby 1.8.6 and Ruby-GNOME2 rel.: 2-0.17.0-rc1) there seems to be a problem in this area, and I suggest you use "Gtk::Dialog#vbox .add" instead, since only a single widget can ve added to the Gtk::Dialog#vbox.

You add buttons to Gtk::Dialog using Gtk::Dialog.new, Gtk::Dialog#add_button, Gtk::Dialog#add_buttons, or Gtk::Dialog#add_action_widget. When clicking the button a signal called "response" with a response ID that you specified is emitted. 

If you want to block waiting for a dialog to return before returning control flow to your code, you can call Gtk::Dialog#run. This function enters a recursive main loop and waits for the user to respond to the dialog, returning the response ID corresponding to the button the user clicked.

Though for a simple dialog like the one in the following example, you can build your own dialogue in reality you'd probably use Gtk::MessageDialog to save yourself some work. But you'd need to create the dialog contents manually if you had more than a simple message in the dialog. 


{{image_right("dialog-msg-01.png")}}
{{br}}

 #!/usr/bin/env ruby
 require 'gtk2'

 # Create a new message dialog telling the user that button was clicked.
 def button_clicked (parent)
   dialog = Gtk::Dialog.new(
       "Information",
       parent,
       Gtk::Dialog::MODAL,
       [ Gtk::Stock::OK, Gtk::Dialog::RESPONSE_OK ]
   )
   dialog.has_separator = false
   label = Gtk::Label.new("The button was clicked!")
   image = Gtk::Image.new(Gtk::Stock::DIALOG_INFO, Gtk::IconSize::DIALOG)

   hbox = Gtk::HBox.new(FALSE, 5)
   hbox.border_width = 10
   hbox.pack_start_defaults(image);
   hbox.pack_start_defaults(label);

   # Add the message in a label, and show everything we've added to the dialog.
   # dialog.vbox.pack_start_defaults(hbox) # Also works, however dialog.vbox
                                           # limits a single item (element).
   dialog.vbox.add(hbox)
   dialog.show_all
   dialog.run
   dialog.destroy
 end

 window = Gtk::Window.new
 window.border_width = 10
 window.set_size_request(200, -1)
 window.title = "Dialogs"
 window.signal_connect('delete_event') { false }
 window.signal_connect('destroy') { Gtk.main_quit }

 button = Gtk::Button.new("_Click Me")
 button.signal_connect('clicked') { button_clicked(window) }

 window.add(button)
 window.show_all
 Gtk.main

=== Creating the Dialog

The first thing you need to do when the dialogue triggering button is pressed in the main window is create the Gtk::Dialog widget. The first two parameters specify the title of the dialogue window and the reference to the parent window. 

   Gtk::Dialog.new(title,
                   parent,
                   flags,
                   [ buton_face, response_id ],
                   ...
   )
The dialogue will be set as the transient window of the parent window, which allows the window manager to centre the dialogue over the main window and keep it on top if required. You can set this parameter to nil if you do not want the parent window to be known or recognized by the dialogue. Next, you can specify one or more dialogue flags which are defined at Gtk::Dialog#Flags. There are three available values:

  * MODAL: Force the dialogue to remain in focus on top of the parent window until closed. The user will be prevented from interacting with the parent. See also Gtk::Window#set_modal(true).
  * DESTROY_WITH_PARENT: Destroy the dialogue when the the parent parent is destroyed, but do not force the dialogue to be in focus. This will create a non-modal dialog unless you call Gtk::Dialog#run, See also: Gtk::Window#set_destroy_with_parent.
  * NO_SEPARATOR: If set, no separator bar will be placed between the buttons in the action area and the dialogue contents.

=== Response Identifiers

When a dialogue is fully constructed, one method of showing the dialogue is by calling Gtk::Dialog#run {...}. This method will return an integer called response identifier when complete. It will also prevent the user from interacting with anything outside the dialogue until it is either destroyed or an action area button is clicked.

--- run {|response| ... }

    Blocks in a recursive main loop until the dialogue either emits the response signal, or user closes the dialogue (i.e. it is destroyed) Regardless of what flags you set, the dialogue will always be modal when you call this method because it calls Gtk::Window#set_modal. If the dialogue is is manually destroyed by the user during the call to Gtk::Dialog#run, Gtk::Dialog returns Gtk::Dialog::RESPONSE_NONE. Otherwise, it returns the response ID from signal emission referring to the button that was clicked. Destroying the dialogue during Gtk::Dialog#run is a very bad idea, because your post-run code won't know whether the dialogue was destroyed or not. Before entering the recursive main loop, Gtk::Dialog#run calls Gtk::Widget#show on the dialogue for you. Note that you still need to show any children of the dialogue yourself. After Gtk::Dialog#run returns, you are responsible for hiding or destroying the dialogue if you wish to do so.

    Typical usage of this method might be:

      dialog.run do |response|
        case response
          when Gtk::Dialog::RESPONSE_ACCEPT
            do_application_specific_something()
          else
            do_nothing_since_dialog_was_cancelled()
        end
        dialog.destroy
      end

    * {|response| ... } : A block or nothing.
       * response: response ID.
    * Returns : response ID




In the above program we have used a few items we have not discussed yet. They are related to Gtk::Image. While you should be familiar with the Gtk::Stock items, Gtk::IconSize is new. Short of explaining details let us have a look at the constants defined for this item:

:GtkIconSize
  * Gtk::IconSize::INVALID
  * Gtk::IconSize::MENU
  * Gtk::IconSize::SMALL_TOOLBAR
  * Gtk::IconSize::LARGE_TOOLBAR
  * Gtk::IconSize::BUTTON
  * Gtk::IconSize::DND
  * Gtk::IconSize::DIALOG
