= Ruby/GStreamer: Olá Mundo
{{link("tut-gst-elements-state", nil, "tut-gst", "tut-gst-helloworld-conclusion")}}

Criaremos uma primeira aplicação simples, um tocador completo de MP3, usando os componentes de GStreamer padrões. O tocador lerá de um arquivo que seja fornecido como o primeiro argumento para o programa.

== O Código

  require 'gst'

  Gst.init
  unless ARGV.length == 1
    $stderr.puts "Uso: #{__FILE__} <arquivo mp3>"
    exit 1
  end

  # cria um novo "pipeline" para guardar os elementos
  pipeline = Gst::Pipeline.new

  # cria um leitor de disco
  filesrc = Gst::ElementFactory.make("filesrc")
  filesrc.location = ARGV.first

  # agora é hora de pegar o decodificador
  decoder = Gst::ElementFactory.make("mad")

  # e um "sink" de áudio
  audiosink = Gst::ElementFactory.make("osssink")

  # adiciona objetos ao "pipeline" principal
  pipeline.add(filesrc, decoder, audiosink)

  # conecta os elementos
  filesrc >> decoder >> audiosink

  # inicia a tocar
  pipeline.play

  while pipeline.iterate do end

  # para o "pipeline"
  pipeline.stop

== O Código Explicado

Vamos através deste exemplo passo a passo.

A primeira coisa que você tem que fazer é carregar a biblioteca Ruby/GStreamer e inicializar o framework.

  require 'gst'
  Gst.init
  ...

Iremos criar um "pipeline" vazio. Como você viu na introdução básica, esse "pipeline" guardará e gerenciará todos os elementos que nós iremos carregar nele.

  ...
  # cria um novo "pipeline" para guardar os elementos
  pipeline = Gst::Pipeline.new
  ...

A gente usa o construtor padrão para um "pipeline": Gst::Pipeline.new.

A gente então cria um elemento de origem de disco. O elemento de origem de disco é capaz de ler de um arquivo. A gente usa o mecanismo padrão de propriedade de GLib::Object para configurar uma propriedade do elemento: o arquivo de onde será lido. 

  ...
  # cria um leitor de disco
  filesrc = Gst::ElementFactory.make("filesrc")
  filesrc.location = ARGV.first
  ...
  
((*Nota*)) Você pode verificar se filesrc.nil? para verificar a criação do elemento de origem de disco.

Agora a gente cria o elemento decodificador de MP3. Isso assume que o plugin 'mad' está instalado no sistema onde a aplicação for executada.

  ...
  # agora é hora de pegar o decodificador
  decoder = Gst::ElementFactory.make("mad")
  ...

O Gst::ElementFactory.make pode levar dois argumentos: uma string que irá identificar o elemento que você precisa e um segundo argumento: como você quer nomear o elemento. O nome do elemento é aldo que você pode escolher e pode ser usado para recuperar o elemento de um "bin/pipeline". Aqui a gente escolheu não fornecer um nome para o elemento, isso significa que o GStreamer irá gerar automaticamente um nome para a gente.

Finalmente a gente cria o nosso elemento "sink" de áudio. Esse elemento será capaz de tocar o áudio usando OSS.

  ...
  # e um "sink" de áudio
  audiosink = Gst::ElementFactory.make("osssink")
  ...

A gente então adiciona os elementos ao "pipeline".

  ...
  # adiciona objetos ao "pipeline" principal
  pipeline.add(filesrc, decoder, audiosink)
  ...

A gente conecta os diferentes "pads" dos elementos, assim:

  ...
  # conecta os elementos
  filesrc >> decoder >> audiosink
  ...

Agora a gente criou um "pipeline" completo. A gente pode visualizar o "pipeline" como a seguir:

{{image_left("en:hello-world.png")}}
{{br}}

Tudo está configurado para começar a tocar. A gente usa os códigos a seguir para alterar o estado do "pipeline":

  ...
  # inicia a tocar
  pipeline.play
  ...

((*Nota*)) O GStreamer cuidará dos estados "READY" e "PAUSED" para você ao sair de "NULL" para "PLAYING". 

Como a gente não usa threads, nada vai acontecer ainda. A gente tem que chamar Gst::Bin#iterate para executar uma iteração do "pipeline".

  ...
  while pipeline.iterate do end
  ...

O método Gst::Bin#iterate retornará "true" a menos que algo interessante tenha ocorrido dentro do "pipeline". Quando o final do arquivo foi alcançado, o método Gst::Bin#iterate retornará "false" e aí a gente pode finalizar o loop.

  ...
  # para o "pipeline"
  pipeline.stop

((*Nota*)) Não esqueça de para o "pipeline" após o uso. Isso liberará todos os recursos seguros pelos elementos.

== Executando o Olá Mundo

Apenas salve o código em um arquivo chamado (({helloworld.rb})) e faça:

  ruby helloworld.rb foo.mp3