= テンプレートからソースコード(Rubyスクリプト)へ
さて、後はテンプレートを編集していきます。というのは半分正解で半分不正解です。

前章でも

「"xxxx is not implemented yet."と表示されるようになっていますので自分で実装したいところから書き換えて行くイメージ」

と書きました。実際それで動きますし、Ruby-GNOME2-0.9.1までは確かにその方法が一般的（？）でした。
でも、その方法だと「機能追加などでGUIを変更したとき、hwedit_glade.rbを毎回作り直す（バックアップを取っておいてシグナルハンドラ部分を書き直す」というような「手動マージ作業」を行う必要があります。
もっと複雑なこと、たとえば自前の定数を書いてみたり、メソッドを追加してみたりするとなおさらマージ作業が大変になりますし、Ruby/Libglade2がバージョンアップしたときに自動的に追加されるメソッドが増えるかもしれません。
このように、ruby-glade-create-templateは最初の1回のテンプレート生成だけは使えるのですが、2度目以降はあまり使えないツールになってしまい、とたんに生産性が落ちてしまいます。

そこで、ここでは、hwedit_glade.rbに触れることなく別ファイルにソースコードを書いておくようにして、少しでもその辺の面倒くささを回避する方法を推奨します（Ruby-GNOME2-0.10.0以降）。


== まずはコピペ
一番最初にhwedit_glade.rbを生成したとき、これをコピーして、（この例では）hwedit.rbという名前にします。
次に、このファイルを編集します。以下に例を示します。（変更部分のみ）

  require 'hwedit_glade'
 
  class Hwedit < HweditGlade 
  #  include GetText

  #  attr :glade

冒頭を、hwedit_glade.rbを読み込んで実行しHweditGladeのサブクラスを定義する形に書き換えます。コメントアウトした部分は不要なので削除します。

    def initialize(path_or_data, root = nil, domain = nil, localedir = nil, flag = GladeXML::FILE)
      super(path_or_data, root, domain, localedir, flag)
      bindtextdomain(domain, localedir, nil, "")
    end

親クラスのinitializeを呼び出した後（super）、親クラスのinitializeで実行済みのbindtextdomainを再度呼び出しています。これは"hwedit_glade.rb"を編集せずに、ローカライズ用データの出力時の文字コードを正しく指定するためです。上記のように文字コード名に空文字列を指定しておくと、プログラム実行時のロケールに合わせたものが自動で選択されます（MS Windowsではそのように動作しました）。文字コード無指定のbindtextdomainを実行しなかった場合、HweditGladeクラスでのbindtextdomain実行時に指定したUTF-8が有効なままになるので、たとえばMS Windowsのコンソールウィンドウにローカライズ用データ文字列を出力すると文字化けします。

    def on_main_window_delete_event(widget, arg0)
      false
    end
    def on_main_window_destroy(widget)
      Gtk.main_quit
    end

「((<プライマリ（メイン）ウィンドウを作る|libglade2-tut-mainwindow>))」のページで説明したように、プログラムのウィンドウのクローズボタンをクリックしたときに正しくプログラムを終了させるのに最低限必要な処理を書きます。（今の時点ではon_main_window_delete_eventは変更しなくても動作しますが）

※　他のシグナルハンドラもカスタマイズが必要になったときのために消さずに残しておきます。

要はinitializeとシグナルハンドラを上書きするようなサブクラスを作るわけです。
この部分だけ、きっと手間に感じると思いますが、一度作れば後は楽チンなこと間違いなしです。

  end
  
  # Main program
  if __FILE__ == $0
    # Set values as your own application. 
    PROG_PATH = "hwedit.glade"
    PROG_NAME = "hwedit"
    Hwedit.new(PROG_PATH, nil, PROG_NAME)
    Gtk.main
  end

PROG_PATHとPROG_NAMEは適切な値に書き直します。また、HweditGlade.newとなっている行もHwedit.newに変更します。

PROG_PATHはhwedit.gladeを置くPATHです。上記例ではこのツールを実行するディレクトリに置いているのでそのままにしてありますが、実際にアプリケーションとして公開する場合はちょっと考えなければなりません。
一般的にはMS Windowsであればc:\ruby\share\hwedit\glade\配下、Linux/FreeBSDであれば、/usr/share/hwedit/gladeに置けば良いでしょう。

これらの値は以下のようにすれば取得できます。

 require 'rbconfig'
 datadir = Config::CONFIG["datadir"]
 
したがって、先のPROG_PATHはこれを指定してしまうというのも一案でしょう。
私はこの辺の設定周りは別ファイル化(config.rbとか)にして、インストーラを起動するときに自動的に生成するようにしています。

=== シグナルハンドラの実装
さて、後は気の向くままにシグナルハンドラたちを実装しましょう。@glade["textview1"]というような形でそれぞれウィジェットのインスタンスを呼び出すことができます。"textview1"はGlade-2上で設定した（あるいはデフォルトのままではウィジェット + 番号という形になる）ウィジェット名です。
ただ、いちいちそのように書くのも手間なので良く使うウィジェットはインスタンス変数に代入しておくと便利です。

例えばこんな感じです。

  def initialize(path_or_data, root = nil, domain = nil, localedir = nil, flag = GladeXML::FILE)
    super(path_or_data, root, domain, localedir, flag)
    bindtextdomain(domain, localedir, nil, "Shift-JIS")
    
    @editor = @glade['textview1']
    @opendlg = @glade['filechooser']
    @aboutdlg = @glade['aboutdialog']
  end

以下、シグナルハンドラの実装例です。まずは簡単な所で、"Edit"メニューの"Cut(切り取り)"、"Copy(コピー)"、"Paste(貼り付け)"コマンドを実装してみます。

  def on_paste1_activate(widget)
    @editor.paste_clipboard
  end

  def on_copy1_activate(widget)
    @editor.copy_clipboard
  end

  def on_cut1_activate(widget)
    @editor.cut_clipboard
  end

以上（笑）。Gtk::TextViewのおかげです。ちなみにTextViewウィジェットの右クリック（コンテキスト）メニュー内のコマンドは実装する必要すらありません。デフォルトで動作します。

次は、"Help"メニューの"About"コマンドを選択した時に、Gladeで作っておいたアバウトダイアログを表示する例です。

  def on_about1_activate(widget)
    @aboutdlg.run do |response|
      case response
      when Gtk::Dialog::RESPONSE_DELETE_EVENT
        puts "RESPONSE_DELETE_EVENT"
      when Gtk::Dialog::RESPONSE_CLOSE
        puts "RESPONSE_CLOSE"
      end
    end
    @aboutdlg.hide
  end

Gtk::Dialog#runは、ダイアログ上で何らかの"response" Signalが発生するまで待機し、Signalを受け取ると関連付けられたブロックを実行してメソッドを抜けます。"response" Signalとは、"response ID"が設定されたボタンが押されるか、またはダイアログ枠のクローズボタン（これを押したというイベントにも"response ID"が設定されています）が押された時に発生するSignalです。"response ID"はブロック引数として渡されるので、ブロック内でこの値に応じた処理を行うことができます。

コード中の定数は事前定義されたIDです。((<「Gtk2チュートリアル」の「ダイアログ」のページ|gtk2-tut-dialog>))などに一覧があります。Gtk::Dialog::RESPONSE_CLOSEはGlade上でボタンのプロパティに表示されるものと違いますが、あれをそのまま使うと、定義されていないというエラーが出てしまうので、Gtk::Dialog::RESPONSE_??の方を使うのが簡単です。個々のIDの対応はすぐわかると思います。

ただアバウトダイアログの場合、"response ID"の値によって処理を分ける必要はないので、以下のようなコードで済ませてしまうのが普通です。

  def on_about1_activate(widget)
    @aboutdlg.run
    @aboutdlg.hide
  end

Gtk::Dialog#runは、どのボタンを押してもダイアログが閉じる処理の場合には便利ですが、そうでない場合、他のウィジェットと同じ方法でシグナルハンドラを設定することもできます。詳しくは((<「Gtk2チュートリアル」の「ダイアログ」のページ|gtk2-tut-dialog>))を見て下さい。

(まだ未完成)
