= Gtk::TextView クラス
Gtk::TextBufferの内容を表示するウィジェット
#Widget that displays a Gtk::TextBuffer.

（このページを編集する方へ((-翻訳済みの部分も一部原文をコメントアウトの形で残してあります。修正の参考にして下さい。-))）

== Object Hierarchy
* Object
  * GLib::Instantiatable
    * GLib::Object
      * Gtk::Object
        * Gtk::Widget
          * Gtk::Container
            * Gtk::TextView

== クラスメソッド
--- Gtk::TextView.new(buffer = nil)
    　指定されたバッファの内容を表示する新しいGtk::TextViewを作成します。一つのバッファを複数のウィジェットで共有することもできます。bufferがnilの場合、自動的にデフォルトのバッファが作成されます。
#    Creates a new Gtk::TextView widget displaying the buffer. One buffer can be shared among many widgets. buffer may be nil to create a default buffer.
    * buffer: Gtk::TextBuffer 
    * 戻り値: 新しいGtk::TextView

== インスタンスメソッド
--- buffer
    　Gtk::TextViewに表示されているバッファを取得します。
#    Returns the Gtk::TextBuffer being displayed by the Gtk::TextView.
    * 戻り値: Gtk::TextBuffer 
--- buffer=(buffer)
    　Gtk::TextViewに表示するバッファを設定します。
#    Sets buffer as the buffer being displayed by the Gtk::TextView. 
    * buffer: Gtk::TextBuffer 
    * 戻り値: buffer
--- set_buffer(buffer)
    　Gtk::TextView#buffer=と同じです。
#    Same as Gtk::TextView#buffer=.
    * buffer: Gtk::TextBuffer 
    * 戻り値: self

--- scroll_to_mark(mark, within_margin, use_align, xalign, yalign)
    　表示エリアのxalignとyalignが指し示す位置にmarkが来るようにGtk::TextViewをスクロールします。xalignに0.0が指定された場合、左端を意味し、1.0が指定された場合、右端を意味します。yalignに0.0が指定された場合、上端を意味し、1.0が指定された場合、下端を意味します。xalign、yalignともに、0.5の場合は中央の位置が指定されたことを意味します。{{br}}　use_alignにfalseが指定された場合、markが表示エリアに入るまでの必要最低限の距離をスクロールします, possibly not scrolling at all。{{br}}　within_marginに指定した値（0.0以上0.5未満）の分だけ有効な表示エリアが小さくなります。
#    Scrolls the Gtk::TextView so that mark is on the screen in the position indicated by xalign and yalign. An alignment of 0.0 indicates left or top, 1.0 indicates right or bottom, 0.5 means center. If use_align is false, the text scrolls the minimal distance to get the mark onscreen, possibly not scrolling at all. The effective screen for purposes of this method is reduced by a margin of size within_margin.
    * mark: Gtk::TextMark 
    * within_margin: 表示エリアサイズに対するマージンの割合（0.0以上0.5未満）
#    * within_margin: margin as a 0.0, 0.5 fraction of screen size 
    * use_align: アラインメント引数を使用するかどうかを表す真偽値（falseの場合mark位置が表示エリアに入るまでの必要最低限の距離をスクロールします）
    * xalign: 表示エリア内での、横方向のmarkのアラインメント
    * yalign: 表示エリア内での、縦方向のmarkのアラインメント
    * 戻り値: self

--- scroll_to_iter(iter, within_margin, use_align, xalign, yalign)
    　表示エリアのxalignとyalignが指し示す位置にiterが来るようにGtk::TextViewをスクロールします。xalignに0.0が指定された場合、左端を意味し、1.0が指定された場合、右端を意味します。yalignに0.0が指定された場合、上端を意味し、1.0が指定された場合、下端を意味します。xalign、yalignともに、0.5の場合は中央の位置が指定されたことを意味します。{{br}}　use_alignにfalseが指定された場合、iterが表示エリアに入るまでの必要最低限の距離をスクロールします, possibly not scrolling at all。{{br}}　within_marginに指定した値（0.0以上0.5未満）の分だけ有効な表示エリアが小さくなります。{{br}}　【注意】　このメソッドは、実行の直前に計算されたバッファ内の行の高さを使用します。そして行の高さはidleハンドラの中で計算されることに注意する必要があります。もし行の高さが計算される前にこのメソッドが呼び出されてしまった場合、望んだ結果にならないかもしれません。予期しない結果を避けるために、Gtk::TextView#scroll_to_mark( which saves a point to be scrolled to after line validation)を利用することを検討してください。
#    Scrolls the Gtk::TextView so that iter is on the screen in the position indicated by xalign and yalign. An alignment of 0.0 indicates left or top, 1.0 indicates right or bottom, 0.5 means center. If use_align is false, the text scrolls the minimal distance to get the mark onscreen, possibly not scrolling at all. The effective screen for purposes of this method is reduced by a margin of size within_margin. NOTE: This method uses the currently-computed height of the lines in the text buffer. Note that line heights are computed in an idle handler; so this method may not have the desired effect if it's called before the height computations. To avoid oddness, consider using Gtk::TextView#scroll_to_mark which saves a point to be scrolled to after line validation.
    * iter: Gtk::TextIter 
    * within_margin: 表示エリアサイズに対するマージンの割合（0.0以上0.5未満）
    * use_align: アラインメント引数を使用するかどうかを表す真偽値（falseの場合mark位置が表示エリアに入るまでの必要最低限の距離をスクロールします）
    * xalign: 表示エリア内での、横方向のiterのアラインメント
    * yalign: 表示エリア内での、縦方向のiterのアラインメント
    * 戻り値: スクロールが行われた場合、trueが返ります。

--- scroll_mark_onscreen(mark)
    　指定されたmarkが表示エリアに入るまでの必要最低限だけGtk::TextViewをスクロールします。
#    Scrolls the Gtk::TextView the minimum distance such that mark is contained within the visible area of the widget.
    * mark: Gtk::TextViewのバッファ（Gtk::TextBuffer）内にあるmark
    * 戻り値: self

--- move_mark_onscreen(mark)
    　バッファ内の指定されたmarkを現在表示されているエリアに移動します。
#    Moves a mark within the buffer so that it's located within the currently-visible text area.
    * mark: Gtk::TextMark 
    * 戻り値: markが移動した場合（表示されているエリアになかった場合）、trueを返します。

--- place_cursor_onscreen
    　バッファ内のカーソルを現在表示されているエリアに移動します。（もし表示エリアになければ）
#    Moves the cursor to the currently visible region of the buffer, if it isn't there already.
    * 戻り値: カーソルを移動する必要があった場合、trueを返します。

--- visible_rect
    　バッファの現在表示されているエリアをバッファ内座標で取得します。バッファ内座標はGtk::TextView#buffer_to_window_coordsでウィンドウ内座標に変換することができます。
#    Returns the currently-visible region of the buffer, in buffer coordinates. Convert to window coordinates with Gtk::TextView#buffer_to_window_coords.
    * 戻り値: Gdk::Rectangle

--- get_iter_location(iter)
    　iterの位置にある文字を、任意の座標に含むGdk::Rectangleを取得します。Gdk::Rectangleが持つ値はバッファ内座標です。バッファ内座標はGtk::TextView#buffer_to_window_coordsでウィンドウ内座標に変換することができます。
#    Gets a Gdk::Rectangle which roughly contains the character at iter. The Gdk::Rectangle position is in buffer coordinates; use Gtk::TextView#buffer_to_window_coords to convert these coordinates to coordinates for one of the windows in the text view.
    * iter : GtkTextIter 
    * 戻り値: iterの位置にある文字を、任意の座標に含むGdk::Rectangle

--- get_line_at_y(y)
    　座標yの位置にある行の先頭を表すGtk::TextIterを取得します。yはバッファ内座標を指定して下さい。ウィンドウ内座標からバッファ内座標を得るには、Gtk::TextView#window_to_buffer_coordsを使用して下さい。戻り値のline_topはnilでなければ、iterを取得した行の上端の座標になります。
#    Gets the Gtk::TextIter at the start of the line containing the coordinate y. y is in buffer coordinates, convert from window coordinates with Gtk::TextView#window_to_buffer_coords. If non-nil, line_top will be the coordinate of the top edge of the line.
    * y : y座標
    * 戻り値: [target_iter, line_top]
       * target_iter : Gtk::TextIter 
       * line_top: iterを取得した行の上端の座標

--- get_line_yrange(iter)
    　指定されたiterを含む行の上端のy座標と行の高さを取得します。取得される座標はバッファ内座標です。バッファ内座標はGtk::TextView#buffer_to_window_coordsでウィンドウ内座標に変換することができます。
#    Gets the y coordinate of the top of the line containing iter, and the height of the line. The coordinate is a buffer coordinate; convert to window coordinates with Gtk::TextView#buffer_to_window_coords.
    * iter : GtkTextIter 
    * 戻り値: [y, height]
       * y: y座標
       * height: 行の高さ

--- get_iter_at_location(x, y)
    　バッファ内座標x, yの位置のGtk::TextIterを取得します。座標は表示エリアだけでなく、バッファ全体から見たものになります。指定する座標は、イベントから取得したものでない場合、Gtk::TextView#window_to_buffer_coordsでバッファ内座標に変換する必要があります。
#    Retrieves the iterator at buffer coordinates x and y. Buffer coordinates are coordinates for the entire buffer, not just the currently-displayed portion. If you have coordinates from an event, you have to convert those to buffer coordinates with Gtk::TextView#window_to_buffer_coords.
    * x: バッファ内x座標
    * y: バッファ内y座標
    * 戻り値: Gtk::TextIter 

--- get_iter_at_position(x, y)
    　バッファ内の座標x, yの位置にある文字を指し示すGtk::TextIterを取得します。座標は表示エリアだけでなく、バッファ全体から見たものになります。指定する座標は、イベントから取得したものでない場合、Gtk::TextView#window_to_buffer_coordsでバッファ内座標に変換する必要があります。{{br}}　このメソッドは、カーソル位置（文字の間）を指し示すGtk::TextIterを返すGtk::TextView#get_iter_at_locationとは違うことに注意してください。((-【訳注：】　これはメソッドの動作を見た上での推測ですが、Gtk::TextView#get_iter_at_locationは、仮に座標の場所をクリックした場合にカーソルが現れる場所を表すGtk::TextIterを返すメソッドだと思われます。つまり、指定した座標がバッファ内のある文字の前半分（日本語、英語などの場合は左側）のエリアに含まれる時は、文字の手前のカーソル位置を表すGtk::TextIterが返り、座標が文字の後ろ半分（日本語、英語などの場合は右側）のエリアに含まれる時は、文字の後ろのカーソル位置を表すGtk::TextIterが返るという具合です。それに対し、get_iter_at_positionは、常に座標上にある文字の手前のカーソル位置を表すGtk::TextIterが返るようです。戻り値のtrailingは、指定した座標が文字の前半分にある時には0が返り、後ろ半分の時には1が返るようです。メソッドの説明に、文字を指し示すGtk::TextIterを返すとありますが、これは結局offsetがその文字の位置と一致するGtk::TextIterを返す、という意味ではないかと思われます。（この注は推測なので、間違っている可能性もあります）-))((* Since 2.6 *))
#    Retrieves the iterator pointing to the character at buffer coordinates x and y. Buffer coordinates are coordinates for the entire buffer, not just the currently-displayed portion. If you have coordinates from an event, you have to convert those to buffer coordinates with Gtk::TextView#window_to_buffer_coords.
#    Note that this is diffferent from Gtk::TextView#get_iter_at_location, which returns cursor locations, i.e. positions between characters.  ((* Since 2.6 *))
    * x: バッファ内x座標
#    * x: x position, in buffer coordinates
    * y: バッファ内y座標
#    * y: y position, in buffer coordinates
    * 戻り値: [iter, trailing]
       * iter: Gtk::TextIter
       * trailing: a trailing

--- buffer_to_window_coords(win_type, buffer_x, buffer_y)
    　座標buffer_x, buffer_yをwin_typeのウィンドウタイプのウィンドウ内座標に変換します。戻り値はwindow_x, window_yに格納されます。{{br}}　存在しないウィンドウの座標に変換することはできないので注意して下さい。（Gtk::TextView#set_border_window_sizeを参照）
#    Converts coordinate (buffer_x, buffer_y) to coordinates for the window win, and stores the result in (window_x, window_y).
#    Note that you can't convert coordinates for a nonexisting window (see Gtk::TextView#set_border_window_size).
    * win_type: ((<GtkTextWindowType|Gtk::TextView#GtkTextWindowType>)) ただし Gtk::TextView::WINDOW_PRIVATE を除く。
#    * win_type: a ((<GtkTextWindowType|Gtk::TextView#GtkTextWindowType>)) except Gtk::TextView::WINDOW_PRIVATE 
    * buffer_x: バッファ内x座標
    * buffer_y: バッファ内y座標
    * 戻り値: [window_x, window_y]
       * window_x: ウィンドウ内x座標
       * window_y: ウィンドウ内y座標

--- window_to_buffer_coords(win_type, window_x, window_y)
    　win_typeのウィンドウタイプのウィンドウ内座標をバッファ内座標に変換します。戻り値はbuffer_x, buffer_yに格納されます。{{br}}　存在しないウィンドウの座標を変換することはできないので注意して下さい。（Gtk::TextView#set_border_window_sizeを参照）
#    Converts coordinates on the window identified by win to buffer coordinates, storing the result in (buffer_x,buffer_y).
#    Note that you can't convert coordinates for a nonexisting window (see Gtk::TextView#set_border_window_size).
    * win_type : ((<GtkTextWindowType|Gtk::TextView#GtkTextWindowType>)) ただし Gtk::TextView::WINDOW_PRIVATE を除く。
    * window_x: ウィンドウ内x座標
    * window_y: ウィンドウ内y座標
    * 戻り値: [buffer_x, buffer_y]
       * buffer_x: バッファ内x座標
       * buffer_y: バッファ内y座標

--- get_window(win_type)
#    Retrieves the Gdk::Window corresponding to an area of the text view; possible windows include the overall widget window, child windows on the left, right, top, bottom, and the window that displays the text buffer. Windows are nil and nonexistent if their width or height is 0, and are nonexistent before the widget has been realized.
    　指定したwin_typeに対応するGdk::Windowを取得します。取得できるのは、ウィジェット全体を表すウィンドウ（win_type=Gtk::TextView::WINDOW_WIDGET）、上下左右の子ウィンドウ（win_type=Gtk::TextView::WINDOW_TOP、win_type=Gtk::TextView::WINDOW_BOTTOM、win_type=Gtk::TextView::WINDOW_LEFT、win_type=Gtk::TextView::WINDOW_RIGHT。border windowのこと。border windowについてはGtk::TextView#set_border_window_sizeを参照）、およびテキストバッファを表示するウィンドウ（win_type=Gtk::TextView::WINDOW_TEXT）です。{{br}}　ウィンドウの横幅あるいは縦幅が0である時はこれらのウィンドウは存在せず、nilが返ります。またウィジェットが具体化される（realized）前の状態の時も存在しません。
    * win_type: 取得したいウィンドウの((<GtkTextWindowType|Gtk::TextView#GtkTextWindowType>))
    * 戻り値: Gdk::Window または nil 

--- get_window_type(window)
#    Usually used to find out which window an event corresponds to. If you connect to an event signal on Gtk::TextView, this method should be called on event.window to see which window it was.
    　このメソッドは通常、あるイベントがどのウィンドウで起きたかを調べるために使用されます。あるイベントシグナルをGtk::TextViewにconnectしていた場合、event.window（event=イベント系シグナルのハンドラの第2引数）に対してこのメソッドを呼び出すことで、ウィンドウ（のタイプ）を知ることができます。
    * window: Gdk::Window
    * 戻り値: ((<GtkTextWindowType|Gtk::TextView#GtkTextWindowType>)) 

--- get_border_window_size(type)
#    Gets the width of the specified border window. See Gtk::TextView#set_border_window_size.
    　指定したタイプのborder windowの幅を取得します。下のGtk::TextView#set_border_window_sizeも参照してください。
    * type: 幅を取得したいborder windowのタイプ（((<GtkTextWindowType|Gtk::TextView#GtkTextWindowType>))）
    * 戻り値: ウィンドウの幅

--- set_border_window_size(type, size)
#    Sets the width of Gtk::TextView::WINDOW_LEFT or Gtk::TextView::WINDOW_RIGHT, or the height of Gtk::TextView::WINDOW_TOP or Gtk::TextView::WINDOW_BOTTOM. Automatically destroys the corresponding window if the size is set to 0, and creates the window if the size is set to non-zero. This method can only be used for the "border windows," it doesn't work with Gtk::TextView::WINDOW_WIDGET, Gtk::TextView::WINDOW_TEXT, or Gtk::TextView::WINDOW_PRIVATE.
    　Gtk::TextView::WINDOW_LEFT（に対応するウィンドウ）やGtk::TextView::WINDOW_RIGHTの横幅、もしくはGtk::TextView::WINDOW_TOPやGtk::TextView::WINDOW_BOTTOMの縦幅を設定します。{{br}}　サイズを0に設定した場合、そのウィンドウは破棄されます。また、0より大きい値を設定した場合、（もしなければ）そのウィンドウが生成されます。{{br}}　このメソッドはborder windowに対してのみ使用することができ、Gtk::TextView::WINDOW_WIDGET、Gtk::TextView::WINDOW_TEXT、Gtk::TextView::WINDOW_PRIVATEに対しては動作しません。{{br}}　訳注：　border windowとは、Gtk::TextViewウィジェットの内側に、テキスト表示領域（Gtk::TextView::WINDOW_TEXT？）の四方を囲む形で表示される4つのGdk::Windowのことで、デフォルトの幅は0です（存在しない）。Gtk::TextView::WINDOW_LEFTやGtk::TextView::WINDOW_RIGHTは、Gtk::TextViewのleft_marginプロパティやrigth_marginプロパティとは関係ありません。
    * type: 幅を変更したいウィンドウの((<GtkTextWindowType|Gtk::TextView#GtkTextWindowType>))
    * size: 設定したい縦幅または横幅
    * 戻り値: self

--- forward_display_line(iter)
#    Moves the given iter forward by one display (wrapped) line. A display line is different from a paragraph. Paragraphs are separated by newlines or other paragraph separator characters. Display lines are created by line-wrapping a paragraph. If wrapping is turned off, display lines and paragraphs will be the same. Display lines are divided differently for each view, since they depend on the view's width; paragraphs are the same in all views, since they depend on the contents of the Gtk::TextBuffer.
    　指定されたiterを画面上（折り返された状態）の1行分だけテキストの末尾に向かって移動します。画面上の1行は段落（paragraph）とは異なります。段落は改行やその他の段落区切り文字列によって区切られたテキストのことです。一方、画面上の1行は段落の一部が折り返されただけのものである場合があります。折り返し（wrapping）がオフになっている場合のみ両者は一致します。画面上の1行はviewの幅によって内容が変化しますが、段落はデータそのもの（Gtk::TextBufferの中身）を指すため、そのようなことはありません。{{br}}　訳注：　実際には画面上の次の行の先頭に移動します。
    * iter: Gtk::TextIter 
    * 戻り値: iterが実際に移動し、かつ、もう一度移動できる場所にある場合のみtrue（訳注：　実際の動作は「iterが実際に移動した場合true」となるようです）

--- backward_display_line(iter)
#    Moves the given iter backward by one display (wrapped) line. A display line is different from a paragraph. Paragraphs are separated by newlines or other paragraph separator characters. Display lines are created by line-wrapping a paragraph. If wrapping is turned off, display lines and paragraphs will be the same. Display lines are divided differently for each view, since they depend on the view's width; paragraphs are the same in all views, since they depend on the contents of the Gtk::TextBuffer.
    　指定されたiterを画面上（折り返された状態）の1行分だけテキストの先頭に向かって移動します。画面上の1行は段落（paragraph）とは異なります。段落は改行やその他の段落区切り文字列によって区切られたテキストのことです。一方、画面上の1行は段落の一部が折り返されただけのものである場合があります。折り返し（wrapping）がオフになっている場合のみ両者は一致します。画面上の1行はviewの幅によって内容が変化しますが、段落はデータそのもの（Gtk::TextBufferの中身）を指すため、そのようなことはありません。{{br}}　訳注：　実際には画面上の前の行の先頭または末尾に移動します。移動時に改行文字をまたぐかどうかによって動作が変わるようですが、どういう仕様でそうなるのかちょっと想像がつきません。
    * iter: Gtk::TextIter 
    * 戻り値: iterが実際に移動し、かつ、もう一度移動できる場所にある場合のみtrue（訳注：　実際の動作は「iterが実際に移動した場合true」となるようです）
#true if iter was moved and is not on the end iterator 

--- forward_display_line_end(iter)
#    Moves the given iter forward to the next display line end. A display line is different from a paragraph. Paragraphs are separated by newlines or other paragraph separator characters. Display lines are created by line-wrapping a paragraph. If wrapping is turned off, display lines and paragraphs will be the same. Display lines are divided differently for each view, since they depend on the view's width; paragraphs are the same in all views, since they depend on the contents of the Gtk::TextBuffer.
    　指定されたiterを画面上（折り返された状態）の行末に移動します。画面上の1行は段落（paragraph）とは異なります。段落は改行やその他の段落区切り文字列によって区切られたテキストのことです。一方、画面上の1行は段落の一部が折り返されただけのものである場合があります。折り返し（wrapping）がオフになっている場合のみ両者は一致します。画面上の1行はviewの幅によって内容が変化しますが、段落はデータそのもの（Gtk::TextBufferの中身）を指すため、そのようなことはありません。
    * iter: Gtk::TextIter 
    * 戻り値: iterが実際に移動し、かつ、もう一度移動できる場所にある場合のみtrue（訳注：　実際の動作は「iterが実際に移動した場合true」となるようです）
#true if iter was moved and is not on the end iterator 

--- backward_display_line_start(iter)
#    Moves the given iter backward to the next display line start. A display line is different from a paragraph. Paragraphs are separated by newlines or other paragraph separator characters. Display lines are created by line-wrapping a paragraph. If wrapping is turned off, display lines and paragraphs will be the same. Display lines are divided differently for each view, since they depend on the view's width; paragraphs are the same in all views, since they depend on the contents of the Gtk::TextBuffer.
    　指定されたiterを画面上（折り返された状態）の行頭に移動します。画面上の1行は段落（paragraph）とは異なります。段落は改行やその他の段落区切り文字列によって区切られたテキストのことです。一方、画面上の1行は段落の一部が折り返されただけのものである場合があります。折り返し（wrapping）がオフになっている場合のみ両者は一致します。画面上の1行はviewの幅によって内容が変化しますが、段落はデータそのもの（Gtk::TextBufferの中身）を指すため、そのようなことはありません。
    * iter: a Gtk::TextIter 
    * 戻り値: iterが実際に移動し、かつ、もう一度移動できる場所にある場合のみtrue（訳注：　実際の動作は「iterが実際に移動した場合true」となるようです）
#true if iter was moved and is not on the end iterator 

--- starts_display_line(iter)
    Determines whether iter is at the start of a display line. See Gtk::TextView#forward_display_line for an explanation of display lines vs. paragraphs.
    * iter: a Gtk::TextIter 
    * 戻り値: true if iter begins a wrapped line 

--- move_visually(iter, count)
#    Moves iter up or down by count display (wrapped) lines. See Gtk::TextView#forward_display_line for an explanation of display lines vs. paragraphs.
    　指定されたiterをcountに等しい画面上の文字数分だけ移動します。countが正の数ならテキストの末尾に向かって、負の数ならテキストの先頭に向かって移動します。{{br}}　訳注：　この項目はhttp://library.gnome.org/devel/gtk/stable/GtkTextView.htmlに記述されている内容と完全に食い違っていたため、左記のページの内容を元に書きました。この翻訳の方が実際の動作と一致しています。
    * iter: Gtk::TextIter 
    * count: 移動したい文字数
#number of lines to move 
    * 戻り値: iterが実際に移動し、かつ、もう一度移動できる場所にある場合のみtrue（訳注：　実際の動作は「iterが実際に移動した場合true」となるようです）
#true if iter moved and is not on the end iterator 

--- add_child_at_anchor(child)
    Adds a child widget in the text buffer, at the given anchor.
    * child: a Gtk::Widget 
    * anchor: a Gtk::TextChildAnchor in the Gtk::TextBuffer for the Gtk::TextView 
    * 戻り値: self

--- add_child_in_window(child, which_window, xpos, ypos)
    Adds a child at fixed coordinates in one of the text widget's windows. The window must have nonzero size (see Gtk::TextView#set_border_window_size). Note that the child coordinates are given relative to the Gdk::Window in question, and that these coordinates have no sane relationship to scrolling. When placing a child in Gtk::TextView::WINDOW_WIDGET, scrolling is irrelevant, the child floats above all scrollable areas. But when placing a child in one of the scrollable windows (border windows or text window), you'll need to compute the child's correct position in buffer coordinates any time scrolling occurs or buffer changes occur, and then call Gtk::TextView#move_child to update the child's position. Unfortunately there's no good way to detect that scrolling has occurred, using the current API; a possible hack would be to update all child positions when the scroll adjustments change or the text buffer changes. See bug 64518 on bugzilla.gnome.org for status of fixing this issue.
    * child: a Gtk::Widget 
    * which_window: which window the child should appear in 
    * xpos: X position of child in window coordinates 
    * ypos: Y position of child in window coordinates 
    * 戻り値: self

--- move_child(child, xpos, ypos)
    Updates the position of a child, as for Gtk::TextView#add_child_in_window.
    * child: child widget already added to the text view 
    * xpos: new X position in window coordinates 
    * ypos: new Y position in window coordinates 
    * 戻り値: self

--- wrap_mode
    Gets the line wrapping for the view.
    * 戻り値: the line wrap setting ((<GtkWrapMode|Gtk::TextTag#GtkWrapMode>))
--- wrap_mode=(wrap_mode)
    Sets the line wrapping for the view.
    * wrap_mode : a ((<GtkWrapMode|Gtk::TextTag#GtkWrapMode>)) 
    * 戻り値: wrap_mode
--- set_wrap_mode(wrap_mode)
    Same as Gtk::TextView#wrap_mode=.
    * wrap_mode : a ((<GtkWrapMode|Gtk::TextTag#GtkWrapMode>)) 
    * 戻り値: self

--- editable?
    Returns the default editability of the Gtk::TextView. Tags in the buffer may override this setting for some ranges of text.
    * 戻り値: whether text is editable by default 
--- editable=(setting)
    Sets the default editability of the Gtk::TextView. You can override this default setting with tags in the buffer, using the "editable" attribute of tags.
    * setting: true if it's editable 
    * 戻り値: setting
--- set_editable
    Same as Gtk::TextView#editable=.
    * setting: true if it's editable 
    * 戻り値: self

--- cursor_visible?
    Find out whether the cursor is being displayed.
    * 戻り値: true if the insertion mark is visible 
--- cursor_visible=(setting)
    Toggles whether the insertion point is displayed. A buffer with no editable text probably shouldn't have a visible cursor, so you may want to turn the cursor off.
    * setting: true if to show the insertion cursor 
    * 戻り値: setting
--- set_cursor_visible(setting)
    Same as Gtk::TextView#cursor_visible=.
    * setting: true if to show the insertion cursor 
    * 戻り値: self

--- overwrite?
    Returns whether the Gtk::TextView is in overwrite mode or not.   ((* Since 2.4 *)) 
    * 戻り値: true if overwrite.
--- overwrite=(setting)
    Changes the Gtk::TextView overwrite mode. ((* Since 2.4 *))
    * setting: true if overwrite.
    * 戻り値: setting
--- set_overwrite(setting)
    Same as Gtk::TextView#overwrite=. ((* Since 2.4 *))
    * setting: true if overwrite.
    * 戻り値: self

--- pixels_above_lines
    Gets the default number of pixels to put above paragraphs.
    * 戻り値: default number of pixels above paragraphs 
--- pixels_above_lines=(pixels_above_lines)
    Sets the default number of blank pixels above paragraphs in the Gtk::TextView. Tags in the buffer for the Gtk::TextView may override the defaults.
    * pixels_above_lines: pixels above paragraphs 
    * 戻り値: pixels_above_lines
--- set_pixels_above_lines(pixels_above_lines)
    Same as Gtk::TextView#pixels_above_lines=.
    * pixels_above_lines: pixels above paragraphs 
    * 戻り値: self

--- pixels_below_lines
    Gets the value set by Gtk::TextView#pixels_below_lines=.
    * 戻り値: default number of blank pixels below paragraphs 
--- pixels_below_lines=(pixels below paragraphs)
    Sets the default number of pixels of blank space to put below paragraphs in the Gtk::TextView. May be overridden by tags applied to the Gtk::TextView's buffer.
    * pixels_below_lines: pixels below paragraphs
    * 戻り値: pixels below paragraphs
--- set_pixels_below_lines(pixels_below_lines)
    Same as Gtk::TextView#pixels_below_lines=.
    * pixels_below_lines: pixels below paragraphs
    * 戻り値: self

--- pixels_inside_wrap
    Gets the value set by Gtk::TextView#pixels_inside_wrap=.
    * 戻り値: default number of pixels of blank space between wrapped lines 
--- pixels_inside_wrap=(pixels_inside_wrap)
    Sets the default number of pixels of blank space to leave between display/wrapped lines within a paragraph. May be overridden by tags in the Gtk::TextView's buffer.
    * pixels_inside_wrap: default number of pixels between wrapped lines 
    * 戻り値: pixels_inside_wrap
--- set_pixels_inside_wrap(pixels_inside_wrap)
    Same as Gtk::TextView#pixels_inside_wrap=.
    * pixels_inside_wrap: default number of pixels between wrapped lines 
    * 戻り値: self

--- justification
    Gets the default justification of paragraphs in the Gtk::TextView. Tags in the buffer may override the default.
    * 戻り値: default justification 
--- justification=(justification)
    Sets the default justification of text in the Gtk::TextView. Tags in the view's buffer may override the default.
    * justification: justification 
    * 戻り値: justification
--- set_justification(justification)
    Same as Gtk::TextView#justification=.
    * justification: justification 
    * 戻り値: self

--- left_margin
    Gets the default left margin size of paragraphs in the Gtk::TextView. Tags in the buffer may override the default.
    * 戻り値: left margin in pixels 
--- left_margin=(left_margin)
    Sets the default left margin for text in the Gtk::TextView. Tags in the buffer may override the default.
    * left_margin: left margin in pixels 
    * 戻り値: left_margin
--- set_left_margin(left_margin)
    Same as Gtk::TextView#left_margin=.
    * left_margin: left margin in pixels 
    * 戻り値: self

--- right_margin
    Gets the default right margin for text in the Gtk::TextView. Tags in the buffer may override the default.
    * 戻り値: right margin in pixels 
--- right_margin=(right_margin)
    Sets the default right margin for text in the Gtk::TextView. Tags in the buffer may override the default.
    * right_margin: right margin in pixels 
    * 戻り値: right_margin
--- set_right_margin(right_margin)
    Same as Gtk::TextView#right_margin=.
    * right_margin: right margin in pixels 
    * 戻り値: self

--- indent
    Gets the default indentation of paragraphs in the Gtk::TextView. Tags in the view's buffer may override the default. The indentation may be negative.
    * 戻り値: number of pixels of indentation 
--- indent=(indent)
    Sets the default indentation for paragraphs in the Gtk::TextView. Tags in the buffer may override the default.
    * indent : indentation in pixels 
    * 戻り値: indent
--- set_indent(indent)
    Same as Gtk::TextView#indent=.
    * indent : indentation in pixels 
    * 戻り値: self

--- tabs
    Gets the default tabs for text_view. Tags in the buffer may override the defaults. The returned array will be nil if "standard" (8-space) tabs are used.
    * 戻り値: copy of default tab array, or nil if "standard" tabs are used
--- tabs=(tabs)
    Sets the default tab stops for paragraphs in the Gtk::TextView. Tags in the buffer may override the default.
    * tabs: tabs as a Pango::TabArray 
    * 戻り値: tabs
--- set_tabs(tabs)
    Same as Gtk::TextView#tabs=.
    * tabs: tabs as a Pango::TabArray 
    * 戻り値: self

--- accepts_tab?
    Returns whether pressing the Tab key inserts a tab characters. See Gtk::TextView#accepts_tab=.
    * 戻り値: true if pressing the Tab key inserts a tab character, false if pressing the Tab key moves the keyboard focus. ((* Since 2.4 *))
--- accepts_tab=(accepts_tab)
    Sets the behavior of the text widget when the Tab key is pressed. If accepts_tab is true a tab character is inserted. If accepts_tab is false the keyboard focus is moved to the next widget in the focus chain.
    * accepts_tab: true if pressing the Tab key should insert a tab character, false, if pressing the Tab key should move the keyboard focus. ((* Since 2.4 *))
    * 戻り値: accepts_tab
--- set_accepts_tab(accepts_tab)
    Same as Gtk::TextView#accepts_tab=. ((* Since 2.4 *))
    * accepts_tab: true if pressing the Tab key should insert a tab character, false, if pressing the Tab key should move the keyboard focus. ((* Since 2.4 *))
    * 戻り値: self

--- default_attributes
    Returns a copy of the default text attributes. These are the attributes used for text unless a tag overrides them. You'd typically pass the default attributes in to Gtk::TextIter#attributes in order to get the attributes in effect at a given text position.
    * 戻り値 : a new Gtk::TextAttributes 

--- backspace
    Emits backspace signal.
    * 戻り値: self
--- copy_clipboard
    Emits copy-clipboard signal.
    * 戻り値: self
--- cut_clipboard
    Emits cut-clipboard signal.
    * 戻り値: self
--- delete_from_cursor(type, arg2)
    Emits delete-from-cursor signal.
    * type: ((<GtkDeleteType|Gtk#GtkDeleteType>))
    * arg2: Integer
    * 戻り値: self
--- insert_at_cursor(str)
    Emits insert-at-cursor signal.
    * str: a String
    * 戻り値: self
--- move_cursor(step, count, textend_selection)
    Emits move-cursor signal.
    * step: ((<GtkMovementStep|Gtk#GtkMovementStep>))
    * count: the number of step units to move (Integer)
    * extend_selection: true if the move should extend the selection, otherwise false
    * 戻り値: self
--- move_focus(type)
    Emits move-focus signal.
    * type: ((<GtkDirectionType|Gtk#GtkDirectionType>))
    * 戻り値: self
--- move_viewport(step, arg2)
    Emits move-viewport signal.
    * step: ((<GtkScrollStep|Gtk#GtkScrollStep>))
    * arg2: Integer
    * 戻り値: self
--- page_horizontally(arg1, arg2)
    Emits page-horizontally signal.
    * arg1: Integer
    * arg2: true or false
    * 戻り値: self
--- paste_clipboard
    Emits paste-clipboard signal.
    * 戻り値: self
--- select_all(setting)
    Emits select-all signal.
    * setting: true or false
    * 戻り値: self
--- set_anchor
    Emits set-anchor signal.
    * 戻り値: self
--- set_scroll_adjustments(adj1, adj2)
    Emits set-scroll-adjustments signal.
    * adj1: Gtk::Adjustment
    * adj2: Gtk::Adjustment
    * 戻り値: self
--- toggle_overwrite
    Emits toggle-overwrite signal.
    * 戻り値: self

== 定数
=== GtkTextWindowType
--- WINDOW_PRIVATE
--- WINDOW_WIDGET
--- WINDOW_TEXT
--- WINDOW_LEFT
--- WINDOW_RIGHT
--- WINDOW_TOP
--- WINDOW_BOTTOM

=== Priority
--- PRIORITY_VALIDATE
The priority at which the text view validates onscreen lines in an idle job in the background(Gdk::PRIORITY_REDRAW + 5).

== プロパティ
--- accepts-tab: true or false (Read/Write)
    Whether Tab will result in a tab character being entered. ((* Since 2.4 *))
    * Default value: true

--- buffer: Gtk::TextBuffer (Read/Write)
    The buffer which is displayed.

--- cursor-visible: true or false (Read/Write)
    If the insertion cursor is shown
    * Default value: true

--- editable: true or false (Read/Write)
    Whether the text can be modified by the user
    * Default value: true

--- indent: Integer (Read/Write)
    Amount to indent the paragraph, in pixels
    * Allowed values: >= 0
    * Default value: 0

--- justification: Integer (Read/Write)
    Left, right, or center justification
    * Default value: Gtk::JUSTIFY_LEFT

--- left-margin: Integer (Read/Write)
    Width of the left margin in pixels
    * Allowed values: >= 0
    * Default value: 0

--- overwrite: true or false (Read/Write)
    Whether entered text overwrites existing contents. ((* Since 2.4 *))
    * Default value: false

--- pixels-above-lines: Integer (Read/Write)
    Pixels of blank space above paragraphs.
    * Allowed values: >= 0
    * Default value: 0  

--- pixels-below-lines: Integer (Read/Write)
    Pixels of blank space below paragraphs.
    * Allowed values: >= 0
    * Default value: 0  

--- pixels-inside-wrap: Integer (Read/Write)
    Pixels of blank space between wrapped lines in a paragraph.
    * Allowed values: >= 0
    * Default value: 0  

--- right-margin: Integer (Read/Write)
    Width of the right margin in pixels.
    * Allowed values: >= 0
    * Default value: 0  

--- tabs: Pango::TabArray (Read/Write)
    Custom tabs for this text

--- wrap-mode: ((<GtkWrapMode|Gtk::TextTag#GtkWrapMode>)) (Read/Write)
    Whether to wrap lines never, at word boundaries, or at character boundaries
    * Default value: Gtk::TextTag::WRAP_NONE

== シグナル
--- backspace: self
     * self: the Gtk::TextView
--- copy-clipboard: self
     * self: the Gtk::TextView
--- cut-clipboard: self
     * self: the Gtk::TextView
--- delete-from-cursor: self, type, arg2
     * self: the Gtk::TextView
     * type: ((<GtkDeleteType|Gtk#GtkDeleteType>))
     * arg2: Number
--- insert-at-cursor: self, arg1
     * self: the Gtk::TextView
     * arg1: String
--- move-cursor: self, step, arg2, arg3
    The ::move-cursor signal is a keybinding signal which gets emitted when the user initiates a cursor movement. Applications should not connect to it, but may emit it with GLib::Instantiatable#signal_emit if they need to control scrolling programmatically.
     * self: the Gtk::TextView
     * step: ((<GtkMovementStep|Gtk#GtkMovementStep>))
     * count: the number of step units to move (Integer)
     * extend_selection: true if the move should extend the selection, otherwise false
--- move-focus: self, type
     * self: the Gtk::TextView
     * type: ((<GtkDirectionType|Gtk#GtkDirectionType>))
--- move-viewport: self, step, arg2
     * self: the Gtk::TextView
     * step: ((<GtkScrollStep|Gtk#GtkScrollStep>))
     * arg2: Integer
--- page-horizontally: self, arg1, arg2
     * self: the Gtk::TextView
     * arg1: Integer
     * arg2: true or false
--- paste-clipboard: self
     * self: the Gtk::TextView
--- populate-popup: self, menu
     * self: the Gtk::TextView
     * menu: Gtk::Menu
--- select-all: self, arg1
     * self: the Gtk::TextView
     * arg1: true or false
--- set-anchor: self
     * self: the Gtk::TextView
--- set-scroll-adjustments: self, adj1, adj2
     * self: the Gtk::TextView
     * adj1: Gtk::Adjustment
     * adj2: Gtk::Adjustment
--- toggle-overwrite: self
     * self: the Gtk::TextView

== 参照
Gtk::TextBuffer, Gtk::TextIter

== ChangeLog
* 2005-06-17 Added GTK+-2.4/2.6 methods. - ((<Masao>))
* 2003-07-29 Added - ((<Masao>))
