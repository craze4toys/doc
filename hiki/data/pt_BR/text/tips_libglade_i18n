= Suportando internacionalização (i18n) em Ruby/Libglade
{{link nil, "Ruby-GNOME2+Tips", nil, nil}}


== Introdução

Este tutorial mostrará como fazer Ruby/Libglade aproveitar as vantagens das strings traduzidas pelo gettext. Para aqueles de vocês que conhecem pouco ou nada dos conceitos do gettext,
ler o ((<manual|URL:http://www.gnu.org/software/gettext/manual>)) é provavelmente uma boa idéia.

Antes de iniciar, certifique-se que você tem o Ruby-GNOME2 instalado.

Enquanto escrevia este tutorial, usei Ruby 1.8.1, Ruby-GNOME2 0.8.1 e gettext
0.12.1 em uma máquina com o Gentoo Linux. Podem existir algumas diferenças entre as versões que causam problemas, então lembre-se disso se algo não funcionar para você. Não sei se ou como qualquer coisa disto funciona no Microsoft Windows. Se alguém gostaria de contribui informação sobre isso, seria de grande ajuda.

Um bocado desta inforamção foi obtida do 
((<FAQ de PyGTK|URL:http://www.async.com.br/faq/pygtk/index.py?req=show&file=faq22.001.htp>)).

== Criando uma interface no Glade

O primeiro passo pe criar a interface com 'glade-2'. Toda vez que você cria um componente (widget) com um campo de texto, o XML gerado terá um campo 'translatable="yes"' adicionado a ele.

Então vá para "Options->LibGlade Options" e selecione 'Save Translatable Strings'. No campo de texto, insira um nome de arquivo para salvar as strings ('glade-msg.c' é um bom nome). A saída (output) está em um formato parecido com C, porque isso é o que o xgettext usará.

== Criando as traduções

((*Nota*)) esta seção é bastante emprestada do ((<FAQ de PyGTK |URL:http://www.async.com.br/faq/pygtk/index.py?req=show&file=faq22.001.htp>)).
mencionado acima. Incluí esta seção para que o leitor não tenha que dar voltas por aí.

Próximo, você quererá criar o arquivo principal de tradução. Para fazer isso, use o comando a seguir:

  xgettext -kN_ -o myapp.pot glade-msg.c

Olhe dentro desse arquivo. Você deverá ver as strings de glade listadas. 

Esse arquivo .pot deverá ser enviado para tradutores. Uma vez que eles recebam o arquivo, eles deverão criar um arquivo '.po'. Como um exemplo, para criar uma tradução Alemã eles usariam:

  LANG=de_DE msginit

Isso criará o arquivo 'de.po', onde as strings traduzidas deverão ser entradas. O arquivo de tradução precisa ser convertido para um formato binário antes de ser usado:

  msgfmt de.po -o myapp.mo

Esse arquivo deverá então ser colocado em um diretório apropriado. Na minha máquina, isso iria em /usr/share/locale/de/LC_MESSAGES/

== Escrevendo seu código

Agora para dizer para Ruby/Libglade carregar os arquivos de 'locale'. Normalmente você teria uma linha no seu código similar a esta:

  @glade = GladeXML.new('myapp.glade') { |handler| method(handler) }

Para conseguir que as strings traduzidas sejam carregadas, você precisa especificar um nome de 'locale' para que o glade saiba qual de arquivo carregar as strings. Altere o código acima para:

  @glade = GladeXML.new('myapp.glade', nil, 'myapp') { |handler| method(handler) }

O terceiro parâmetro, 'myapp', dirá ao glade para procurar por 'myapp.mo'. Agora para carregar a aplicação:

  LANG=de_DE ruby myapp.rb

As strings traduzidas deverão aparecer. Isso é tudo.

== Gerando automaticamente o arquivo de tradução binário

((*Nota*)) esta seção é baseada no código incluído com this section is based on code included with ((<a distribuição ruby-gettext
|URL:http://ponx.s5.xrea.com/hiki/ruby-gettext.html>)) de Masao Mutoh.

Para cada arquivo traduzido, você precisará criar um novo arquivo '.mo'. Com o ((<install.rb|URL:http://i.loveruby.net/en/setup.html>)) de Minero
Aoki isso se torna bastante fácil de automatizar. 

Para este exemplo nós fingiremos que já temos traduções em Espanhol e Alemão criadas, nomeadas 'de.po' e 'es.po', respectivamente.

  cd $PROJECTROOT
  mkdir po
  mkdir po/de
  mkdir po/es
  cp de.po po/de/myapp.po
  cp es.po po/es/myapp.po

Então, no seu diretório principal, crie um arquivo nomeado post-setup.rb que contém:

  require 'fileutils'

  podir = srcdir_root + "/po/"
  modir = srcdir_root + "/data/locale/%s/LC_MESSAGES/"

  Dir.glob("po/*/*.po") do |file|
      lang, basename = /po\/([\w\.]*)\/(.*)\.po/.match(file).to_a[1,2]
      FileUtils.mkdir_p modir % lang
      system("msgfmt #{podir}#{lang}/#{basename}.po -o #{modir}#{basename}.mo" % lang)
  end

Você pode também querer criar o seguinte pre-clean.rb:
  
  Dir.glob("data/**/*.mo").each do |file|
      File.delete(file)
  end

Agora, quando 'ruby install.rb setup' é executado, os arquivos de tradução serão gerados.
No 'ruby install.rb install' eles serão instalados no local correto.

== Conclusão

Espero que isto tenha sido claro. Se as pessoas tiverem problemas, sintam-se livres para me contactarem e tentarei ajudá-las. Gostaria de melhorar este documento, assim também me contacte com correções e etc.

== Autor

Zachary P. Landau (kapheine AT hypa DOT net).

O leitor deve estar avisado que estou longe de ser um expert no assunto. Eu apenas recentemente comecei a tentar adicionar suporte a internacionalização a um dos meus projetos. Enquanto procurava por informação, encontrei apenas pedaços que precisavam ser unidos. Escrevi este tutorial em uma tentativa de evitar que outras pessoas tenham que fazer o mesmo.

Isso dito, eu ficarua feliz em incorporar adições e correções de pessoas que sabem mais sobre o assunto. Por favor me contacte com qualquer informação que você tenha.

== Log de Alterações

:2004-03-20 Zachary P. Landau
 Versão inicial.

Autor da Tradução para Português: ((<Joao Pedrosa|jpedrosa>))