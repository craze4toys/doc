=Listen- und Baumansichten: das Gtk::TreeView-Widget
{{link nil, nil, "tut-treeview", "tut-treeview-components"}}

Das Gtk::TreeView ist ein Widget, das Listen- und Baumansichten mit einzelnen oder mehreren Spalten. Es ersetzt die aus Gtk+ 1.2 stammenden Gtk::CList- und Gtk::CTree-Widgets. Obwohl das Gtk::TreeView komplizierter zu benutzen ist als seine Vorgänger, ist es so viel mächtiger und flexibler, dass die meisten Entwickler es nicht mehr vermissen möchten, wenn Sie es erst einmal verstanden haben.

Der Zweck dieses Kapitels ist nicht eine vollständige Dokumentation des Gtk::TreeView-Widgets - dafür ist die API-Dokumentation da, die zusammen mit diesem Tutorial gelesen werden sollte. Das Ziel ist viel mehr, eine Einleitung in die meistgenutzten Aspekte des Gtk::TreeView-Widgets zu geben und zu demonstrieren, wie verschiedene Gtk::TreeView-Komponenten und -Konzepte zusammenarbeiten. Außerdem wurde ein Versuch gemacht, etwas Licht auf benutzerdefinierte TreeModels und benutzerdefinierte CellRenderer fallen zu lassen, die anscheinend oft erwähnt, aber nur selten erklärt werden.

Entwickler, die eine Quick & Dirty-Einleitung suchen, die ihnen alles erklärt, was sie wissen müssen - und das nach Möglichkeit in weniger als fünf Absätzen - werden diese hier ebenfalls nicht finden. Der Erfahrung des Autors nach werden Entwickler, die nicht verstehen, wie das Gtk::TreeView und die Models zusammenarbeiten, mit Problemen zu kämpfen haben, wenn sie die beschriebenen Beispiele zu bearbeiten versuchen, wohingegen Entwickler, die bereits mit anderen Toolkits gearbeitet haben, in denen das MVC-Design angewendet wird, der Ansicht sein werden, dass die API-Referenz alle notwendigen Informationen in einer kompakteren Form enthält. Wer dem nicht zustimmt, darf natürlich direkt zu dem funktionieren Beispielcode springen.

Bitte beachten Sie, dass die Beispielcodes in den folgenden Abschnitten nicht notwendigerweise demonstrieren, wie ein Gtk::TreeView am besten in einer bestimmten Situation benutzt werden kann. Es gibt verschiedene Wege, um die gleichen Ergebnisse zu erzielen und die Beispiele zeigen diese verschiedenen Wege auf, damit Entwickler in der Lage sind, zu entscheiden, welche Version für ihre jeweilige Aufgabe am besten passt.